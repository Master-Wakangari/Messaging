<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Live Chat</title>
<style>
body {
  font-family: 'Segoe UI', Roboto, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f0f2f5;
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.chat-container {
  flex: 1;
  padding: 15px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-width: 800px;
  margin: 0 auto;
  width: 100%;
  box-sizing: border-box;
}

.message-bubble {
  display: inline-block;
  padding: 12px 16px;
  border-radius: 18px;
  max-width: 75%;
  word-wrap: break-word;
  white-space: pre-wrap;
  font-size: 15px;
  line-height: 1.4;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  position: relative;
}

.user-message {
  background-color: #0084ff;
  color: white;
  align-self: flex-end;
  border-bottom-right-radius: 4px;
}

.other-message {
  background-color: #e4e6eb;
  color: #050505;
  align-self: flex-start;
  border-bottom-left-radius: 4px;
}

.timestamp {
  font-size: 11px;
  color: #65676b;
  margin-top: 4px;
  text-align: right;
}

.loading {
  text-align: center;
  padding: 10px;
  color: #65676b;
}

.error-message {
  color: #ff4d4f;
  text-align: center;
  padding: 15px;
  background: white;
  border-radius: 8px;
  margin: 10px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.debug-info {
  font-size: 12px;
  color: #666;
  margin-top: 10px;
  word-break: break-all;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(5px); }
  to { opacity: 1; transform: translateY(0); }
}

.message-bubble {
  animation: fadeIn 0.3s ease-out;
}

.refresh-button {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: #0084ff;
  color: white;
  border: none;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  font-size: 20px;
  cursor: pointer;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

.refresh-button:hover {
  background: #0073e6;
}

.refresh-button:disabled {
  background: #cccccc;
  cursor: not-allowed;
}
</style>
</head>
<body>

<div class="chat-container" id="chat">
  <div class="loading" id="loading">Loading messages...</div>
</div>

<button class="refresh-button" id="refreshButton" title="Refresh messages">↻</button>

<script>
// Configuration - MUST REPLACE THESE WITH YOUR ACTUAL VALUES
const config = {
  token: "patYOUR_PERSONAL_ACCESS_TOKEN",  // Starts with "pat..." - get from Airtable account
  baseId: "appYOUR_BASE_ID",               // Find in Airtable URL after /app/
  tableName: "Messaging Memory",           // Case-sensitive table name
  refreshInterval: 5000,                   // 5 seconds
  maxRetries: 3,
  retryDelay: 2000
};

// State management
let lastFetchTime = 0;
let retryCount = 0;
let refreshIntervalId = null;

// DOM elements
const chatContainer = document.getElementById("chat");
const loadingIndicator = document.getElementById("loading");
const refreshButton = document.getElementById("refreshButton");

// Format timestamp
function formatTimestamp(timestamp) {
  if (!timestamp) return '';
  const date = new Date(timestamp);
  return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

// Enhanced fetch with better error handling
async function fetchMessages() {
  try {
    loadingIndicator.style.display = 'block';
    
    const response = await fetch(
      `https://api.airtable.com/v0/${config.baseId}/${encodeURIComponent(config.tableName)}?sort[0][field]=Created&sort[0][direction]=asc`, 
      {
        headers: { 
          Authorization: `Bearer ${config.token}`,
          'Content-Type': 'application/json'
        },
        cache: 'no-store'
      }
    );
    
    if (!response.ok) {
      let errorDetails = await response.text();
      try {
        const errorData = JSON.parse(errorDetails);
        errorDetails = errorData.error?.message || JSON.stringify(errorData);
      } catch (e) {
        // If not JSON, keep the raw response text
      }
      
      throw new Error(`HTTP ${response.status}: ${response.statusText}\nDetails: ${errorDetails}`);
    }
    
    const data = await response.json();
    console.log("API Response:", data);
    lastFetchTime = Date.now();
    retryCount = 0;
    return data.records;
    
  } catch (error) {
    console.error('Fetch error:', error);
    retryCount++;
    
    if (retryCount <= config.maxRetries) {
      console.log(`Retrying in ${config.retryDelay/1000} seconds... (${retryCount}/${config.maxRetries})`);
      await new Promise(resolve => setTimeout(resolve, config.retryDelay));
      return fetchMessages();
    } else {
      throw error;
    }
  } finally {
    loadingIndicator.style.display = 'none';
  }
}

// Render messages to the chat container
function renderMessages(messages) {
  if (!messages || messages.length === 0) {
    chatContainer.innerHTML = '<div class="error-message">No messages found.</div>';
    return;
  }

  const fragment = document.createDocumentFragment();
  
  messages.forEach(record => {
    const messageText = record.fields["Message Content"] || "(No text)";
    const sender = record.fields["Sender"] || "Other";
    const timestamp = record.fields["Created"] || record.createdTime;
    
    const messageDiv = document.createElement("div");
    messageDiv.classList.add("message-bubble");
    
    if (sender.toLowerCase() === "me") {
      messageDiv.classList.add("user-message");
    } else {
      messageDiv.classList.add("other-message");
    }
    
    messageDiv.textContent = messageText;
    
    if (timestamp) {
      const timeElement = document.createElement("div");
      timeElement.classList.add("timestamp");
      timeElement.textContent = formatTimestamp(timestamp);
      messageDiv.appendChild(timeElement);
    }
    
    fragment.appendChild(messageDiv);
  });
  
  chatContainer.innerHTML = '';
  chatContainer.appendChild(fragment);
  chatContainer.scrollTop = chatContainer.scrollHeight;
}

// Enhanced error handling
function handleError(error) {
  console.error('Error:', error);
  
  let errorMessage = 'Error loading messages. Please try again later.';
  let debugInfo = '';
  
  if (error.message.includes('403')) {
    errorMessage = 'Access Denied (403 Forbidden)';
    debugInfo = `
      <div class="debug-info">
        <strong>Possible causes:</strong>
        <ul>
          <li>Invalid Personal Access Token</li>
          <li>Token missing required scopes (data.records:read)</li>
          <li>Incorrect base ID or table name</li>
        </ul>
        <strong>How to fix:</strong>
        <ol>
          <li>Verify your token at <a href="https://airtable.com/create/tokens" target="_blank">Airtable Tokens</a></li>
          <li>Ensure token has <code>data.records:read</code> scope</li>
          <li>Check base ID matches your Airtable URL</li>
        </ol>
        <strong>Current configuration:</strong><br>
        Base ID: ${config.baseId}<br>
        Table: ${config.tableName}
      </div>
    `;
  } else if (error.message.includes('404')) {
    errorMessage = 'Resource Not Found (404)';
    debugInfo = `
      <div class="debug-info">
        The table or base could not be found. Verify:
        <ul>
          <li>Base ID is correct</li>
          <li>Table name is exactly as shown in Airtable</li>
          <li>Your token has access to this base</li>
        </ul>
      </div>
    `;
  }
  
  chatContainer.innerHTML = `
    <div class="error-message">
      ${errorMessage}
      <br><br>
      <strong>Error details:</strong><br>
      ${error.message.split('\n')[0]}
      ${debugInfo}
    </div>
  `;
}

// Initialize and load messages
async function loadMessages() {
  try {
    const messages = await fetchMessages();
    renderMessages(messages);
  } catch (error) {
    handleError(error);
  }
}

// Setup auto-refresh
function setupAutoRefresh() {
  if (refreshIntervalId) {
    clearInterval(refreshIntervalId);
  }
  
  refreshIntervalId = setInterval(async () => {
    try {
      const messages = await fetchMessages();
      renderMessages(messages);
    } catch (error) {
      console.error('Auto-refresh error:', error);
    }
  }, config.refreshInterval);
}

// Manual refresh handler
refreshButton.addEventListener('click', async () => {
  refreshButton.disabled = true;
  refreshButton.textContent = '...';
  
  try {
    await loadMessages();
  } finally {
    refreshButton.disabled = false;
    refreshButton.textContent = '↻';
  }
});

// Initial load
document.addEventListener('DOMContentLoaded', () => {
  loadMessages();
  setupAutoRefresh();
});

// Clean up
window.addEventListener('beforeunload', () => {
  if (refreshIntervalId) {
    clearInterval(refreshIntervalId);
  }
});
</script>

</body>
</html>
